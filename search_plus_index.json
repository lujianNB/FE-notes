{"./":{"url":"./","title":"介绍","keywords":"","body":"前端攻城狮简介 俗称：大仙儿 github地址： https://github.com/lujianNB 联系方式：lu1997jian（微信号，加好友记得备注博客。） 描述：前端开发已经有两年了，两年里从一个萌新到现在能独立负责一个项目，成长了很多很多。工作中，学习中还是生活上，所思所学所想所悟会不定时的写在这里和大家分享，可能写的不是很好，希望有缘人看了不要鄙视，有什么意见可以互相交流，彼此成长，大家互相成就！！！ Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:45:43 "},"电子书/电子书.html":{"url":"电子书/电子书.html","title":"电子书","keywords":"","body":"电子书操作 npm i -g gitbook-cli gitbook init 这一步会有一个报错。说找不到apply函数，根据错误注释掉文件里的代码就行，那是兼容低版本的。 生成SUMMARY.md文件，这个文件就是菜单目录 运行 gitbook serve或者build 将生成的_book文件夹里的内容放到gh-pages分支根目录下，就可以访问了。 // 清空gh-pages分支下所有文件执行以下命令就可以了 cp -r _book/* . 如果重定向的话需要有自己的域名，在该分支的settings里配置域名并且设置好域名解析。 Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"封装好的文件/axios封装.html":{"url":"封装好的文件/axios封装.html","title":"axios封装","keywords":"","body":"基于vue对axios封装 像vue中进行请求数据的一般有两种，axios和fetch fetch fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。用起来也不是很舒服， 1）fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 2）fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'}) 3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。 4）fetch没有办法原生监测请求的进度，而XHR可以。 axios axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范。相较而言，axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小。 axios封装代码 import axios from 'axios' import { Message } from 'element-ui' // 消息组建 let _Message = function (params = {}) { let _duration = params.duration || 2000 params.duration = _duration Message(params) } // 创建axios实例 const http = axios.create({ baseURL: '', // api的base_url /* baseURL: \"proxy\", */ // `method` 是创建请求时使用的方法 method: 'post', // 默认是 post headers: { 'Content-Type': 'application/json;charset=UTF-8' } }) // 添加请求拦截器 http.interceptors.request.use( config => { // 在发送请求之前做些什么 // const token = utils.LS.get('token') // token && (config.headers.Authorization = 'Bearer ' + token); const defaultParams = { // 公共参数 web_access: 'webqSoiKwpWVge4TkaryH6MKvOdceGt7ZMaF20g8H0cnXIweb', token: 'kj6tFXDccchnhEqjjQRyyJwVBjXyNgG2GpMVEqYkSeM9E56NbvpG', } config.data = Object.assign({}, defaultParams, config.data) // 接口报错不要axios直接message提示，而自己catch处理的时候 if (config.data && config.data.noErrorMessage) { config.noErrorMessage = true } return config // 此处切记记得将请求参数return出去 }, error => { // 对请求错误做些什么 console.log(error) // for debug Promise.reject(error) } ) // 添加响应拦截器 http.interceptors.response.use( response => { if (response) { let { data, config } = response // 判断是否需要显示错误message提示 const noErrorMessage = config.noErrorMessage const { code, msg } = data if (code !== 0) { noErrorMessage || _Message({ message: msg, type: 'error' }) // if (code === 10001) { // 退出登录 // utils.LS.remove(\"token\"); // window.location = '/login' // } return Promise.reject(data) } return data } else { return {} } }, err => { // 对响应错误做点什么 if (err && err.response) { switch (err.response.status) { case 400: err.message = '请求错误' break case 401: err.message = '未授权，请登录' break case 403: err.message = '拒绝访问' break case 404: err.message = `请求地址出错: ${err.response.config.url}` break case 408: err.message = '请求超时' break case 500: err.message = '服务器内部错误' break case 501: err.message = '服务未实现' break case 502: err.message = '网关错误' break case 503: err.message = '服务不可用' break case 504: err.message = '网关超时' break case 505: err.message = 'HTTP版本不受支持' break default: } // 判断是否需要显示错误message提示 const noErrorMessage = err.config.noErrorMessage; noErrorMessage || _Message({ message: err.message, type: 'error' }) } return Promise.reject(err) } ) export default function (config) { return http(config) } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"封装好的文件/css样式重置.html":{"url":"封装好的文件/css样式重置.html","title":"css样式重置","keywords":"","body":"css样式重置文件 html { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; -webkit-tap-highlight-color: transparent; height: 100%; } body { margin: 0; font-size: 14px; font-family: \"Helvetica Neue\", Helvetica, STHeiTi, Arial, sans-serif; height: 100%; } article, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section,summary { display: block; } audio, canvas, progress, video { display: inline-block; } audio:not([controls]) { display: none; height: 0; } progress { vertical-align: baseline; } a { background: transparent; text-decoration: none; color: #08c; } a:active { outline: 0; } abbr[title] { border-bottom: 1px dotted; } b, strong { font-weight: bold; } dfn { font-style: italic; } mark { background: #ff0; color: #000; } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sup { top: -0.5em; } sub { bottom: -0.25em; } img { max-width: 100%; border: 0; vertical-align: middle; } svg:not(:root) { overflow: hidden; } pre { overflow: auto; white-space: pre; white-space: pre-wrap; word-wrap: break-word; } code, kbd, pre, samp { font-family: monospace, monospace; font-size: 1em; } button, input, optgroup, select, textarea { color: inherit; font: inherit; margin: 0; vertical-align: middle; } button, input, select { overflow: visible; } button, select { text-transform: none; } button, html input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"] { -webkit-appearance: button; cursor: pointer; } [disabled] { cursor: default; } button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; } input { line-height: normal; } input[type=\"checkbox\"], input[type=\"radio\"] { box-sizing: border-box; padding: 0; } input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button { height: auto; } input[type=\"search\"] { -webkit-appearance: textfield; box-sizing: border-box; } input[type=\"search\"]::-webkit-search-cancel-button, input[type=\"search\"]::-webkit-search-decoration { -webkit-appearance: none; } fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; } legend { border: 0; padding: 0; } textarea { overflow: auto; resize: vertical; vertical-align: top; } optgroup { font-weight: bold; } input, select, textarea { outline: 0; } textarea, input { -webkit-user-modify: read-write-plaintext-only; } input::-ms-clear, input::-ms-reveal { display: none; } input::-moz-placeholder, textarea::-moz-placeholder { color: #999; } input:-ms-input-placeholder, textarea:-ms-input-placeholder { color: #999; } input::-webkit-input-placeholder, textarea::-webkit-input-placeholder { color: #999; } .placeholder { color: #999; } table { border-collapse: collapse; border-spacing: 0; } td, th { padding: 0; } h1, h2, h3, h4, h5, h6, p, figure, form, blockquote { margin: 0; } ul, ol, li, dl, dd { margin: 0; padding: 0; } ul, ol { list-style: none outside none; } h1, h2, h3 { line-height: 2; font-weight: normal; } h1 { font-size: 18px; } h2 { font-size: 16px; } h3 { font-size: 14px; } i { font-style: normal; } * { box-sizing: border-box; padding: 0; margin: 0; } .clearfix::before, .clearfix::after { content: \"\"; display: table; } .clearfix::after { clear: both; } /*滚动条样式*/ *::-webkit-scrollbar { width: 4px; height: 4px; } *::-webkit-scrollbar-thumb { border-radius: 10px; -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.8); background: rgba(255,255,255,1); } *::-webkit-scrollbar-track { -webkit-box-shadow: inset 0 0 5px rgba(0,0,0,0.8); border-radius: 0; background: rgba(255,255,255,0.5); } /* fade-transform */ .fade-transform-leave-active, .fade-transform-enter-active { transition: all 0.5s; } .fade-transform-enter { opacity: 0; transform: translateX(-30px); } .fade-transform-leave-to { opacity: 0; transform: translateX(30px); } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"设计模式/代理模式.html":{"url":"设计模式/代理模式.html","title":"代理模式","keywords":"","body":"代理模式 为一个对象提供一个代用品或占位符，以便控制对它的访问 虚拟代理 //真正的图片 let myImage = (function () { let imgNode = document.createElement('img'); document.body.appendChild(imgNode); return { setSrc: function (src) { imgNode.src = src; } } })(); //图片代理 let proxyImage = (function () { let img = new Image; img.onload = function () { myImage.setSrc(this.src); } return { setSrc: function (src) { myImage.setSrc('./loading.svg'); img.src = src; } } })(); proxyImage.setSrc('http://www.cdhrsip.com/static/imgs/high-tech/banner.png?version=201512141756'); 缓存代理 let mult = function () { console.log('开始计算乘积'); let a = 1; for (let i = 0, l = arguments.length; i Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"设计模式/设计模式六大原则.html":{"url":"设计模式/设计模式六大原则.html","title":"设计模式六大原则","keywords":"","body":"设计模式六大原则 单一职责原则 1.理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。 2.总结：一个类只承担一个职责，一个对象只有一种引起他变化的原因。 里氏替换原则 1.理解：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。 2.总结：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 依赖倒置原则 1.理解：举例人吃苹果，我想吃苹果，但是我还想吃橘子，如果按照程序思维的话。就是三个类型，人Class，苹果Class，橘子Class，这种方式冗杂不好维护，不易理解，用水果来抽象化，苹果类继承并实现吃的动作。 2.总结：使用接口或抽象类 接口隔离原则 1.理解:如果一个类实现一个接口，但这个接口中有它不需要的方法，那么就需要把这个接口拆分，把它需要的方法提取出来，组成一个新的接口让这个类去实现。 2.总结：一个接口对实现它的类都是有用的。接口足够小。 迪米特原则(最少知道原则) 1.理解：一个对象应该对其他对象有最少的了解。 2.总结：类中只暴露不得不暴露的，其内部实现不暴露出去。 开闭原则 1.理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能。 2.总结：是扩展不是修改。 Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"设计模式/职责链模式.html":{"url":"设计模式/职责链模式.html","title":"职责链模式","keywords":"","body":"职责链模式 定义 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 优点： 1.可以根据需求变动，任意向责任链中添加 / 删除节点对象。 2.没有固定的“开始节点”，可以从任意节点开始。 缺点：责任链最大的代价就是每个节点带来的多余消耗。当责任链过长，很多节点只有传递的作用，而不是真正地处理逻辑。 // 假设我们负责一个售卖手机的电商网站，经过分别交纳500元定金和200元定金的两轮 // 预定后（订单已在此时生成），现在已经到了正式购买的阶段。 // 公司针对支付过定金的用户有一定的优惠政策。在正式购买后，已经支付过500元定 // 金的用户会收到100元的商城优惠券，200元定金的用户可以收到50元的优惠券，而之前 // 没有支付定金的用户只能进入普通购买模式，也就是没有优惠券，且在库存有限的情况 // 下不一定保证能买到。 // orderType：表示订单类型（定金用户或者普通购买用户）， // code的值为1的时候是500元定金用户，为2的时候是200元定金用户，为3的时候是普通购买用户。 // pay：表示用户是否已经支付定金，值为true或者false， // 虽然用户已经下过500元定金的订单，但如果他一直没有支付定金， // 现在只能降级进入普通购买模式。 // stock：表示当前用于普通购买的手机库存数量，已经支付过500元或者200元定金的用户不受此限制。 let order500 = function (code, pay, stock) { if (code === 1 && pay) { console.log('收到100优惠卷') } else { return 'next' } } let order200 = function (code, pay, stock) { if (code === 2 && pay) { console.log('收到50优惠卷') } else { return 'next' } } let orderNormal = function (code, pay, stock) { if (code === 3 || !pay) { stock ? console.log('没有优惠卷哦') : console.log('没货了') } } // 节点类 class Node { constructor(fn) { this.fn = fn // 当前节点做的事 this.nextNode = null //下一个节点类 } toNextNode(nextNode) { this.nextNode = nextNode // 指定当前节点的下一个节点类 } getResult() { let res = this.fn.apply(this, arguments) res === 'next' && (this.nextNode && this.nextNode.getResult.apply(this.nextNode, arguments)) return res } } // 设置三个节点 let node500 = new Node(order500) let node200 = new Node(order200) let nodeNormal = new Node(orderNormal) // 设置节点指向（职责链） node500.toNextNode(node200) node200.toNextNode(nodeNormal) node500.getResult(1, true, 2) node500.getResult(2, true, 2) node500.getResult(2, false, 2) node500.getResult(3, true, 2) node500.getResult(3, true, 0) Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"项目中遇到的问题/播放海康视频流.html":{"url":"项目中遇到的问题/播放海康视频流.html","title":"播放海康视频流","keywords":"","body":"处理海康威视摄像头得流问题 海康威视得视频流需要控件或者flash，现在得谷歌已经不支持插件和flash了，怎么去处理呢？那就是后端对摄像头得rtsp流进行转换，可以换成hls得视频流（后端这里要注意编码，不然前端不断接受得ts片段是有问题得）。 这里是通过hls.js和dplayer去实现得 首先安装依赖 npm i hls.js dplayer -S 引入依赖进行操作，代码如下： 返 回 import Hls from \"hls.js\"; import Dplayer from \"dplayer\"; export default { name: \"dplayer\", data() { return { dp: null, video: { img: \"\", // img: require(\"../assets/404.jpg\"), video: \"\", }, device_id: \"\", loading: true, imgFlag: false, timer: null, }; }, mounted() { this.device_id = window.utils.CK.get(\"device_id\"); this.initRoom(); }, beforeDestroy() { this.timer && clearTimeout(this.timer); this.video.video && this.outRoom(); }, methods: { loadVideo(videoInfo) { this.dp = new Dplayer({ element: this.$refs.player, video: { pic: videoInfo.img, // 封面 url: videoInfo.video, type: \"customHls\", customType: { customHls: function (video) { const hls = new Hls(); hls.loadSource(video.src); hls.attachMedia(video); }, }, }, autoplay: true, }); }, // 初始化直播间 async initRoom() { let { initRoom } = await import(\"@/api/dplayer\"); let { data: { wait }, } = await initRoom({ device_id: this.device_id, }); this.timer = setTimeout(() => { this.getRoomUrl(); }, 1000 * wait); }, // 获取直播间hls源头 async getRoomUrl() { let { getRoomUrl } = await import(\"@/api/dplayer\"); let { data: { url }, } = await getRoomUrl({ device_id: this.device_id, }); this.loading = false; this.video.video = url; if (this.video.video) { this.loadVideo(this.video); } else { this.imgFlag = true; } }, // 离开直播间停止视频流 async outRoom() { let { outRoom } = await import(\"@/api/dplayer\"); await outRoom({ device_id: this.device_id, }); }, go() { this.$router.go(-1); }, }, }; .lj-dplayer { width: 100%; height: 100%; position: relative; #dplayer { width: 100%; height: 100%; } .return { position: absolute; top: 0; left: 0; z-index: 1000; } .all-screen { width: 800px; height: 500px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 900; } } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"项目中遇到的问题/关于加载3D模型导致所有输入框不能输入的问题.html":{"url":"项目中遇到的问题/关于加载3D模型导致所有输入框不能输入的问题.html","title":"关于加载3D模型导致所有输入框不能输入的问题","keywords":"","body":"关于加载3D模型导致所有输入框不能输入的问题 问题描述 页面的输入框一切正常，但是当进入了三维模型页面后，再去点击输入框会发现输入框不能输入了 问题原因 在使用OrbitControls时有第二个参数，第二个参数的意思是用于事件侦听的HTML，如果不传的话默认是整个dom文档，所以会导致上述问题。 解决方案 在这里可以把用于显示3D图的dom节点传入。建议是，如果单纯做3d显示，可以选择默认的方式；如果是在页面中嵌入3d显示，则需要指定该参数。 // 初始化控制器 this.controls = new OrbitControls(this.camera, this.$el); Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-07-13 16:58:44 "},"项目中遇到的问题/数字精准度问题.html":{"url":"项目中遇到的问题/数字精准度问题.html","title":"数字精准度问题","keywords":"","body":"如何处理让人头疼的前端数字精准度问题 前端的数字存在浮点数问题（受计算机处理精度的影响），如何去很好的解决这个难题呢？一般会采用升幂再降幂的方法。下面是重写的加减乘除方法： // 以下是处理javascript小数精度加减乘除的四个的函数 /** * 必需要传的前两个参数:传入两个要计算的数字 * 非必要传的最后一个参数:自己想要精确的位数 */ const globalConst = { MAX_PRECISION: 8 } // 计算两位数应该乘以的数，为加减乘数服务的函数 function formatNumber(num1, num2) { let r1, r2 try { r1 = num1.toString().split('.')[1].length } catch (e) { r1 = 0 } try { r2 = num2.toString().split('.')[1].length } catch (e) { r2 = 0 } let sum = r1 + r2 let sub = r2 - r1 return { 'max': Math.pow(10, Math.max(r1, r2)), 'sum': Math.pow(10, sum), 'sub': Math.pow(10, sub) } } // 加法 const plus = function (num1, num2, n) { let formatNum = formatNumber(num1, num2).max let result = (num1 * formatNum + num2 * formatNum) / formatNum if (n) { return Number(result.toFixed(n)) } return Number(result.toFixed(globalConst.MAX_PRECISION)) } // 减法 const subtract = function (num1, num2, n) { let formatNum = formatNumber(num1, num2).max let result = (num1 * formatNum - num2 * formatNum) / formatNum if (n) { return Number(result.toFixed(n)) } return Number(result.toFixed(globalConst.MAX_PRECISION)) } // 乘法 const multiply = function (num1, num2, n) { let sum = formatNumber(num1, num2).sum let s1 = Number(num1.toString().replace('.', '')) let s2 = Number(num2.toString().replace('.', '')) let result = (s1 * s2) / sum if (n) { return Number(result.toFixed(n)) } return Number(result.toFixed(globalConst.MAX_PRECISION)) } // 除法 const divide = function (num1, num2, n) { let sub = formatNumber(num1, num2).sub let r1 = Number(num1.toString().replace('.', '')) let r2 = Number(num2.toString().replace('.', '')) let result = (r1 / r2) * sub if (n) { return Number(result.toFixed(n)) } return Number(result.toFixed(globalConst.MAX_PRECISION)) } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"项目中遇到的问题/elementui表格固定列覆盖底部滚动条.html":{"url":"项目中遇到的问题/elementui表格固定列覆盖底部滚动条.html","title":"elementui表格固定列覆盖底部滚动条","keywords":"","body":"elementui表格固定列覆盖底部滚动条 在进行elementui表格固定列的时候，会出现覆盖住底部滚动条的问题 解决方案 .el-table .el-table__fixed { height: auto !important; bottom: 8px; } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:40 "},"项目中遇到的问题/elementui日期限制前后不能超过五天.html":{"url":"项目中遇到的问题/elementui日期限制前后不能超过五天.html","title":"elementui日期限制前后不能超过五天","keywords":"","body":"elementui日期限制前后不能超过五天 template模块 js模块 data(){ return { dcTime: [], // 日期选择器可选择范围 choiceDate: null, pickerOptions: { onPick: ({ maxDate, minDate }) => { // 把选择的第一个日期赋值给一个变量。 this.choiceDate = minDate.getTime(); // 如何你选择了两个日期了，就把那个变量置空 if (maxDate) this.choiceDate = \"\"; }, disabledDate: time => { // 如何选择了一个日期 if (this.choiceDate) { // 5天的时间戳 const one = 5 * 24 * 3600 * 1000; // 当前日期 - one = 5天之前 const minTime = this.choiceDate - one; // 当前日期 + one = 5天之后 const maxTime = this.choiceDate + one; return ( time.getTime() maxTime || // 限制不能选择今天及以后，不能今天用time.getTime() + 1 * 24 * 3600 * 1000 > Date.now() time.getTime() > Date.now() ); } else { // 如果没有选择日期，就要限制不能选择今天及以后 return time.getTime() > Date.now() } } } } } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:40 "},"项目中遇到的问题/ie对于打印时的问题.html":{"url":"项目中遇到的问题/ie对于打印时的问题.html","title":"ie对于打印时的问题","keywords":"","body":"ie对于打印时的问题 打印的页面是根据body内的内容来确定的，一般首页展示，body都会是100%，在谷歌和火狐浏览器都能正常打印，但是在ie会出现多一张空白页的情况，解决这种问题呢可以通过打印的媒体查询，修改body的高度为auto就好了。 Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:40 "},"项目中遇到的问题/ie浏览器使用elementui弹窗遮罩层在最外层.html":{"url":"项目中遇到的问题/ie浏览器使用elementui弹窗遮罩层在最外层.html","title":"ie浏览器使用elementui弹窗遮罩层在最外层","keywords":"","body":"ie浏览器使用elementui弹窗遮罩层在最外层 elementui的dialog组件在ie浏览器中会出现遮罩出现在最外层，原因是使用了vue的transform动画切换，如何解决这个问题呢？需要在组件中添加append-to-body属性为true. Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:40 "},"项目中遇到的问题/vue结合three.js载入多个obj模型交互场景.html":{"url":"项目中遇到的问题/vue结合three.js载入多个obj模型交互场景.html","title":"vue结合three.js载入多个obj模型交互场景","keywords":"","body":"vue结合three.js载入多个obj模型交互场景 应用场景是实现多个三维obj模型导入，进行拼凑，去实现模型的交互，点击，运动等，如果只是简单的建议使用vue-3d-model插件 2022.04.26新增补充踩坑点： 1.解析的时候可能出现源代码报错说什么Handlers.get()没有了，要替代，只需将three-obj-mtl-loader文件下的index.js545行“var loader = THREE.Loader.Handlers.get( url );”注释掉，然后换成“var loader = manager.getHandler(url);”，这个加上的要放在manager定义的下面，网上很多都没去说。 2.在载入obj模型时，如果3dmax导出的mtl材质文件是带图片的，一定要处理好路径，这里建议全部换成线上地址，这里如果出现内部的跨域，在解析之前mtl前加上“mtlLoader.setCrossOrigin(\"Anonymous\");”另外mtl材质里的图片如果是tga格式图片，可以换成png或者jpg的，tga没反应。 3.这里还有一个坑，对一个模型修改颜色，旁边的模型可能也会变色。因为：“threejs中的网格物体对材质的是引用传递，不是值传递，如果material1被mesh1和mesh2用到了，改变mesh1.material.color，则mesh2的材质颜色也改了，在递归渲染的下一次就都生效了”建议单独给每个模型修改颜色直接修改材质,如下所示。 let material = new THREE.MeshBasicMaterial({ color: 0x000000, // 前面FrontSide 背面：BackSide 双面：DoubleSide // side: THREE.DoubleSide, }); obj.children[0].material = material; 安装依赖 npm i three three-css2drender three-obj-mtl-loader three-orbit-controls -S demo import * as THREE from \"three\"; import { OBJLoader, MTLLoader } from \"three-obj-mtl-loader\"; // import { CSS2DRenderer, CSS2DObject } from \"three-css2drender\"; const OrbitControls = require(\"three-orbit-controls\")(THREE); export default { name: \"obj\", data() { return { scene: \"\", light: \"\", camera: \"\", controls: \"\", renderer: \"\", allObj: [ { mtl: \"http://lvhua.cosys.com.cn/uploads/tj.mtl\", object: \"http://lvhua.cosys.com.cn/uploads/tj.obj\", typeName: \"tj\", }, { mtl: \"http://lvhua.cosys.com.cn/uploads/dl.mtl\", object: \"http://lvhua.cosys.com.cn/uploads/dl.obj\", typeName: \"dl\", }, { mtl: \"http://lvhua.cosys.com.cn/uploads/pz.mtl\", object: \"http://lvhua.cosys.com.cn/uploads/pz.obj\", typeName: \"pz\", }, { mtl: \"http://lvhua.cosys.com.cn/uploads/wc.mtl\", object: \"http://lvhua.cosys.com.cn/uploads/wc.obj\", typeName: \"wc\", }, { mtl: \"http://lvhua.cosys.com.cn/uploads/xb.mtl\", object: \"http://lvhua.cosys.com.cn/uploads/xb.obj\", typeName: \"xb\", }, { mtl: \"http://lvhua.cosys.com.cn/uploads/xz.mtl\", object: \"http://lvhua.cosys.com.cn/uploads/xz.obj\", typeName: \"xz\", }, ], }; }, methods: { //初始化three.js相关内容 init() { this.scene = new THREE.Scene(); // this.scene.background = new THREE.Color(0xf0f0f0); this.scene.add(new THREE.AmbientLight(0xffffff)); // 环境光3dmax默认白色 this.light = new THREE.DirectionalLight(0x1e90ff, 1); // 从正上方（不是位置）照射过来的平行光，0.45的强度 this.light.position.set(100, 200, 100); this.light.position.multiplyScalar(0.3); this.scene.add(this.light); // 利用一个轴对象以可视化的3轴以简单的方式。X轴是红色的。Y轴是绿色的。Z轴是蓝色的。这有助于理解在空间的所有三个轴的方向。 let axisHelper = new THREE.AxisHelper(20); // 参数是坐标轴的长度 this.scene.add(axisHelper); // 初始化相机 this.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 ); this.camera.position.set(0, 0, 20); this.camera.lookAt(this.scene.position); // 初始化控制器 this.controls = new OrbitControls(this.camera); this.controls.target.set(0, 0, 10); this.controls.minDistance = 80; this.controls.maxDistance = 400; this.controls.maxPolarAngle = Math.PI / 3; this.controls.update(); // 渲染 this.renderer = new THREE.WebGLRenderer({ alpha: true, }); let pointLight = new THREE.PointLight(); pointLight.color.set(0xffffff); pointLight.intensity = 1; this.camera.add(pointLight); this.scene.add(this.camera); // this.renderer.setClearColor(0x000000); this.renderer.setPixelRatio(window.devicePixelRatio); // 为了兼容高清屏幕 this.renderer.setSize(window.innerWidth, window.innerHeight); this.$el.appendChild(this.renderer.domElement); window.addEventListener(\"resize\", this.onWindowResize, false); // 添加窗口监听事件（resize-onresize即窗口或框架被重新调整大小） }, // 窗口监听函数 onWindowResize() { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); }, animate() { this.controls.update(); requestAnimationFrame(this.animate); this.render(); }, render() { this.renderer.render(this.scene, this.camera); }, // 外部模型加载函数 loadObj({ mtl, object, typeName }) { let objLoader = new OBJLoader(); let mtlLoader = new MTLLoader(); // let _this = this; // 包含材质 // mtlLoader.setPath(\"/static/models/\") mtlLoader.setCrossOrigin(\"Anonymous\"); mtlLoader.load(mtl, (materials) => { // console.log(\"acm\", acm); materials.preload(); objLoader.setMaterials(materials); objLoader.load(object, (obj) => { // console.log(obj); // obj.position.set(0, 0, 0); // 模型摆放的位置 // if (typeName === \"wc\") { // obj.rotation.set(0, Math.PI / 2, 0); // obj.position.set(-4.5, 0, 10); // } // if (typeName === \"xz\") { // // obj.rotation.set(0, Math.PI / 2, 0); // obj.position.set(-9, 0, -3); // } // if (typeName === \"xb\") { // obj.position.set(0, 5, 5); // } obj.typeName = typeName; obj.scale.set(0.0008, 0.0008, 0.0008); // 模型放大或缩小，有的时候看不到模型，考虑是不是模型太小或太大。 this.scene.add(obj); }); }); }, /** * 点击事件 */ mouseClick(event) { this.scene.children.forEach((item) => { if (item.typeName === \"xb\") { let ljaxis = new THREE.Vector3(1, 0, 0); // 向量axis item.rotateOnAxis(ljaxis, Math.PI / 8); // 绕axis轴旋转π/8 } }); // 获取 raycaster 和所有模型相交的数组，其中的元素按照距离排序，越近的越靠前 let intersects = this.getIntersects(event); if (intersects.length) { // intersects[0].object.position.x += 200; // intersects.forEach((item) => { // item.object.position.x += 200; // }); } // console.log(intersects); // console.log(this.scene); // 获取选中最近的 Mesh 对象 }, /** * 将屏幕坐标转换为3d 坐标 */ getIntersects(event) { let mainCanvas = event.path[0]; event.preventDefault(); let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2(); // mouse.x = (event.clientX / window.innerWidth) * 2 - 1; // mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; mouse.x = ((event.clientX - mainCanvas.getBoundingClientRect().left) / mainCanvas.offsetWidth) * 2 - 1; mouse.y = -( (event.clientY - mainCanvas.getBoundingClientRect().top) / mainCanvas.offsetHeight ) * 2 + 1; raycaster.setFromCamera(mouse, this.camera); let intersects = raycaster.intersectObjects(this.scene.children, true); return intersects; }, }, mounted() { this.init(); this.allObj.forEach((item) => { this.loadObj(item); }); this.animate(); // traverse()为three.js提供的递归遍历模型对象方法，getObjectById()、getObjectByName()也可用来查找对象 this.scene.traverse((obj) => { if (obj.typeName === \"wc\") { obj.rotation.set(0, Math.PI / 2, 0); obj.position.set(-4.5, 0, 10); } if (obj.typeName === \"xz\") { // obj.rotation.set(0, Math.PI / 2, 0); obj.position.set(-9, 0, -3); } if (obj.typeName === \"xb\") { obj.position.set(0, 5, 5); } // 打印id属性 console.log(obj.id); // 打印该对象的父对象 console.log(obj.parent); // 打印该对象的子对象 console.log(obj.children); }); }, }; .lj-obj { width: 100%; height: 100%; } 效果图 注意合理利用组对象group，有的交互操作group要比较方便。 Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:40 "},"项目中遇到的问题/vue使用elementui表格布局问题.html":{"url":"项目中遇到的问题/vue使用elementui表格布局问题.html","title":"vue使用elementui表格布局问题","keywords":"","body":"vue使用elementui表格布局问题 当使用el-table时，如果设置宽度为100%，在页面某个组件收缩时（可收缩的菜单），导致表格不能很好的自适应，这时可以改变100%为99% Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:40 "},"项目中遇到的问题/vue中使用elementui表格动态合并数据.html":{"url":"项目中遇到的问题/vue中使用elementui表格动态合并数据.html","title":"vue中使用elementui表格动态合并数据","keywords":"","body":"vue中使用elementui表格动态合并数据 直接贴代码了有注释 运行指导 编辑 删除 export default { name: \"runDiagnosticsTable\", data() { return { spanArr: [], //遍历数据时，根据相同的标识去存储记录 pos: 0, // 二维数组的索引 }; }, props: { loading: { type: Boolean, default: true, }, emptyText: { type: String, default: \" \", }, tableData: { type: Array, default: () => {}, }, }, computed: { newTableData() { let arr = []; this.tableData.forEach((item) => { arr = [...arr, item.param]; }); arr = Array.from(new Set(arr)); let newArr = []; arr.forEach((item) => { this.tableData.forEach((ele) => { if (ele.param === item) newArr = [...newArr, ele]; }); }); this.mergeSpan(newArr); return newArr; }, }, mounted() {}, methods: { // 合并行 mergeSpan(data) { let that = this; //页面展示的数据，不一定是全部的数据，所以每次都清空之前存储的 保证遍历的数据是最新的数据。以免造成数据渲染混乱 that.spanArr = []; that.pos = 0; //遍历数据 data.forEach((item, index) => { //判断是否是第一项 if (index === 0) { this.spanArr.push(1); this.pos = 0; } else { //不是第一项时，就根据标识去存储 if (data[index].param === data[index - 1].param) { // 查找到符合条件的数据时每次要把之前存储的数据+1 this.spanArr[this.pos] += 1; this.spanArr.push(0); } else { // 没有符合的数据时，要记住当前的index this.spanArr.push(1); this.pos = index; } } }); }, objectSpanMethod({ row, column, rowIndex, columnIndex }) { // 页面列表上 表格合并行 -> 第几列(从0开始) // 需要合并多个单元格时 依次增加判断条件即可 if (columnIndex === 0) { // 二维数组存储的数据 取出 const _row = this.spanArr[rowIndex]; const _col = _row > 0 ? 1 : 0; return { rowspan: _row, colspan: _col, }; //不可以return {rowspan：0， colspan: 0} 会造成数据不渲染， 也可以不写else，eslint过不了的话就返回false } else { return false; } }, }, }; .lj-run-diagnostics-table { width: 100%; height: 100%; display: flex; flex-direction: column; .title { width: 100%; height: 30px; line-height: 30px; font-size: 14px; font-family: Source Han Sans CN; color: #ddefff; } .table { width: 100%; flex: 1; } } .lj-run-diagnostics-table { .el-table { margin-top: 10px !important; td.oneCol { border-right: 1px solid #0071ff !important; background: rgba(0, 113, 255, 0.2); } } .lj-table-header { background: rgba(0, 113, 255, 0.5) !important; height: 50px !important; > th { padding: 0; font-size: 12px; font-family: Source Han Sans CN; color: #b7ddff; border-bottom: 1px solid #0071ff !important; } } .lj-table-row { background: rgba(0, 113, 255, 0.2) !important; height: 50px !important; > td { padding: 0; font-size: 12px; font-family: Source Han Sans CN; color: #b7ddff; border-bottom: 1px solid #0071ff !important; } } .el-table::before { content: none !important; } } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"js/深拷贝与浅拷贝.html":{"url":"js/深拷贝与浅拷贝.html","title":"深拷贝与浅拷贝","keywords":"","body":"深拷贝与浅拷贝 谈到深拷贝与浅拷贝首先要将数据类型的概念。js中有两种类型的数据，基本类型和引用类型。基本类型有undefined，null，String，Number，Boolean，Symbol，BigInt。引用类型有Object，Array，Function，Date，Map，Math等。为什么要在这里说这个呢？ 深拷贝和浅拷贝都是针对引用类型的。因为基本类型在存储中都是直接存在栈中的，而引用类型的内容是存在堆中，栈中存放的是这个引用类型的地址，然后有个指针指向堆中的数据。 浅拷贝 浅拷贝（一层），仅仅是复制了引用，彼此之间的操作会互相影响。 深拷贝 深拷贝（多层），在堆中重新分配内存，不同的地址，相同的值，互不影响 浅拷贝实现 // 使用Object.assign解决 // 使用Object.assign()，你就可以没有继承就能获得另一个对象的所有属性，快捷好用。 // Object.assign 方法只复制源对象中可枚举的属性和对象自身的属性。 let obj = { a:1, arr:[2,3]}; let res = Object.assign({}, obj) console.log(res.arr === obj.arr); // true，指向同一个引用 console.log(res === obj); // false // 使用扩展运算符（…）来解决 let obj = { a:1, arr:[2,3]}; let res = {...obj}; console.log(res.arr === obj.arr); // true，指向同一个引用 console.log(res === obj); // false 深拷贝实现 // 开发中常用JSON序列化来进行深拷贝，很好用 // 可以通过 JSON.parse(JSON.stringify(object)) 来解决 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE // 但是该方法也是有局限性的： // 1.会忽略 undefined // 2.不能序列化函数（会忽略函数） // 3.不能解决循环引用的对象（对象成环） // 并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数。 // 拓展一下，MessageChannel（异步通信，一般用于多个web worker并想要在两个web worker之间实现通信的时候）的postMessage传递的数据也是深拷贝的，这和web worker的postMessage一样。而且还可以拷贝undefined和循环引用的对象（函数不行）。 function deepCopy(obj) { return new Promise((resolve) => { const {port1, port2} = new MessageChannel(); port2.onmessage = ev => resolve(ev.data); port1.postMessage(obj); }); } deepCopy(obj).then((copy) => { let copyObj = copy; console.log(copyObj, obj) console.log(copyObj == obj) }); // 递归实现深拷贝（递归比较耗性能，容易造成栈溢出，所以有尾递归的诞生，得看浏览器兼容性，理解尾递归得理解函数的调用帧，之后会专门有一篇讲这个。） const deepClone = function (source, nullVal) { if (!source || typeof source !== 'object') { return source } const targetObj = source.constructor === Array ? [] : {} for (const keys in source) { if (source.hasOwnProperty(keys)) { if (source[keys] && typeof source[keys] === 'object') { targetObj[keys] = deepClone(source[keys]) } else { // 传null防止undefined被过滤 if (nullVal === null) { targetObj[keys] = source[keys] === undefined ? nullVal : source[keys] } else { targetObj[keys] = source[keys] } } } } return targetObj } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"js/事件监听对象.html":{"url":"js/事件监听对象.html","title":"事件监听对象","keywords":"","body":"addEventListener可以监听哪些东西 鼠标事件 事件 触发 click 当用户点击某个对象时调用的事件句柄 contextmenu 在用户点击鼠标右键打开上下文菜单时触发 dblclick 当用户双击某个对象时调用的事件句柄 mousedown 鼠标按钮被按下 mouseenter 当鼠标指针移动到元素上时触发 mouseleave 当鼠标指针移出元素时触发 mousemove 鼠标被移动 mouseover 鼠标移到某元素之上 mouseout 鼠标从某元素移开 mouseup 鼠标按键被松开 键盘事件 事件 触发 keydown 某个键盘按键被按下 keypress 某个键盘按键被按下并松开 keyup 某个键盘按键被松开 框架/对象（Frame/Object）事件 事件 触发 abort 图像的加载被中断 beforeunload 该事件在即将离开页面（刷新或关闭）时触发 error 在加载文档或图像时发生错误 hashchange 该事件在当前 URL 的锚部分发生修改时触发 load 一张页面或一幅图像完成加载 pageshow 该事件在用户访问页面时触发 pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 resize 窗口或框架被重新调整大小 scroll 当文档被滚动时发生的事件 unload 用户退出页面 表单事件 事件 | 触发 | | :---: | :---: | | blur | 元素失去焦点时触发 | | change | 该事件在表单元素的内容改变时触发 | | focus | 元素获取焦点时触发 | | focusin | 元素即将获取焦点是触发 | | focusout | 元素即将失去焦点是触发 | | input | 元素获取用户输入是触发 | | reset | 表单重置时触发 | | search | 用户向搜索域输入文本时触发 | 打印事件 事件 触发 afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 beforeprint 该事件在页面即将开始打印时触发 拖动事件 事件 触发 drag 该事件在元素正在拖动时触发 dragend 该事件在用户完成元素的拖动时触发 dragenter 该事件在拖动的元素进入放置目标时触发 dragleave 该事件在拖动元素离开放置目标时触发 dragover 该事件在拖动元素在放置目标上时触发 dragstart 该事件在用户开始拖动元素时触发 drop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件 事件 触发 abort 事件在视频/音频（audio/video）终止加载时触发 canplay 事件在用户可以开始播放视频/音频（audio/video）时触发 canplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发 durationchange 事件在视频/音频（audio/video）的时长发生变化时触发 ended 事件在视频/音频（audio/video）播放结束时触发 error 事件在视频/音频（audio/video）数据加载期间发生错误时触发 loadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发 loadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发 loadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发 pause 事件在视频/音频（audio/video）暂停时触发 play 事件在视频/音频（audio/video）开始播放时触发 playing 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发 progress 事件在浏览器下载指定的视频/音频（audio/video）时触发 ratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发 seeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发 seeking 事件在用户开始重新定位视频/音频（audio/video）时触发 stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发 suspend 事件在浏览器读取媒体数据中止时触发 timeupdate 事件在当前的播放位置发送改变时触发 volumechange 事件在音量发生改变时触发 waiting 事件在视频由于要播放下一帧而需要缓冲时触发 动画事件 事件 触发 animationend 该事件在 CSS 动画结束播放时触发 animationiteration 该事件在 CSS 动画重复播放时触发 animationstart 该事件在 CSS 动画开始播放时触发 过渡事件 事件 触发 transitionend 该事件在 CSS 完成过渡后触发 其他事件 事件 触发 message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 online 该事件在浏览器开始在线工作时触发 offline 该事件在浏览器开始离线工作时触发 popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发 show 该事件当元素在上下文菜单显示时触发 storage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发 toggle 该事件在用户打开或关闭 元素时触发 wheel 该事件在鼠标滚轮在元素上下滚动时触发 Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"js/cookie与storage.html":{"url":"js/cookie与storage.html","title":"cookie与storage","keywords":"","body":"cookie与storage的区别与用法 cookie cookie非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。 localStorage localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，localStorage有length属性，可以查看其有多少条记录的数据。 sessionStorage sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。 三者的异同 特性|cookie|localStorage|sessionStorage :---:|:---:|:---:|:---: 数据的生命期|一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效|除非被清除，否则永久保存|仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小|4K左右|一般为5MB|一般为5MB 与服务器端通信|每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题|仅在客户端（即浏览器）中保存，不参与和服务器的通信|仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性|需要程序员自己封装，源生的Cookie接口不友好|源生接口可以接受，亦可再次封装来对Object和Array有更好的支持|源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 cookie的封装 const cookie = { get: function(key) { if (document.cookie) { //判断是否有cookie var arr = document.cookie.split('; '); //拆分cookie for (var i = 0; i vue中使用vue-cookies插件对cookie进行封装 ``` // 运行npm i vue-cookies -S安装插件 import vueCookie from 'vue-cookies' vueCookie.config(60 60 24 * 3) // 设置cookie const CK = { // 设置key set: (keyName, value, expireTimes) => { return vueCookie.set(keyName, value, expireTimes) // this }, // 获取key get: (keyName) => { return vueCookie.get(keyName) // value }, // 删除key remove: (keyName) => { return vueCookie.remove(keyName) // true、false }, // 是否存在key isKey: (keyName) => { return vueCookie.isKey(keyName) // true、false }, // 获取所有key keys: () => { return vueCookie.keys() // array } } * localStorage的封装 class Storage { constructor(props) { this.props = props || {} this.source = this.props.source || window.localStorage this.initRun() } initRun() { const reg = new RegExp('expires') let data = this.source let list = Object.keys(data) if (list.length > 0) { list.map((key, v) => { if (!reg.test(key)) { let now = Date.now() let expires = data[${key}__expires__] || Date.now + 1 if (now >= expires) { this.remove(key) } } return key }) } } /** * @description 获取方法 * @param {String} key 键 * @returns value * @memberof Storage */ get(key) { const source = this.source const expired = source[`${key}__expires__`] || Date.now + 1 const now = Date.now() if (now >= expired) { this.remove(key) return } let value = source[key] if (/^\\{.*\\}$/.test(value) || /^\\[.*\\]$/.test(value)) value = JSON.parse(value) return value } /** * @description 存储方法 * @param {String} key 键 * @param {String} value 值 * @param {Number} expired 过期时间，单位分钟，非必填 * @returns value * @memberof Storage */ set(key, value, expired) { if (typeof value === typeof {}) value = JSON.stringify(value) let source = this.source source[key] = value if (expired) { source[`${key}__expires__`] = Date.now() + 1000 * 60 * expired } return value } /** * @description 删除方法 * @param {String} key 键 * @returns value * @memberof Storage */ remove(key) { const data = this.source const value = data[key] delete data[key] delete data[`${key}__expires__`] return value } } ``` Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"js/es11新增.html":{"url":"js/es11新增.html","title":"es11新增","keywords":"","body":"es11新增 matchAll方法 matchAll()方法返回一个包含所有匹配正则表达式的结果的迭代器。使用 for...of 遍历或者使用 操作符 ... Array.from 将其转换成数组。 const reg = /[0-3]/g; const data = '2020'; console.log(data.matchAll(reg));//data.matchAll 的返回值是一个迭代器 console.log([...data.matchAll(reg)]); /** * 0: [\"2\", index: 0, input: \"2020\", groups: undefined] * 1: [\"0\", index: 1, input: \"2020\", groups: undefined] * 2: [\"2\", index: 2, input: \"2020\", groups: undefined] * 3: [\"0\", index: 3, input: \"2020\", groups: undefined] */ Dynamic import(动态导入) 标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。(在 import() 之前，当我们需要根据条件导入模块时，不得不使用 require()) if(XXX) { const menu = import('./menu'); // 注意这里返回的是一个promise对象 } import.meta import.meta 会返回一个对象，有一个 url 属性，返回当前模块的url路径，只能在模块内部使用。 //main.js console.log(import.meta); //{url: \"http://localhost:8080/main.js\"} PS：使用了 http-server 启动 因为 import.meta 必须要在模块内部使用，如果不加 type=\"module\"，控制台会报错：Cannot use 'import.meta' outside a module。 export * as ns from 'module' 可以理解为是将import as ns from './info';export { ns };合并为一句：**不过需要注意的是 export as ns from './info' 并不会真的将导入模块，因此在该模块(menu.js)中，我们是获取不到 ns 的。** Promise.allSettled Promise.all 或者 Promise.race 有的时候并不能满足我们的需求。比如，我们需要在所有的 promise 都结束的时候做一些操作，而并不在乎它们是成功还是失败。在没有 Promise.allSettled 之前，我们需要自己去写实现。 Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的 promise 结果。 可以看到，Promise.allSettled() 的成功的结果是一个数组，该数组的每一项是一个对象，每个对象都有一个 status 属性，值为 fulfilled 或 rejected，如果status 的值是 fulfilled，那么该对象还有一个 value 属性，其属性值是对应的 promise 成功的结果；如果 status 的值是 rejected，那么该对象有一个 reason 属性，其属性值是对应的 promise 失败的原因。 const promise1 = Promise.resolve(100); const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'info')); const promise3 = new Promise((resolve, reject) => setTimeout(resolve, 200, 'name')) Promise.allSettled([promise1, promise2, promise3]). then((results) => console.log(result)); /* [ { status: 'fulfilled', value: 100 }, { status: 'rejected', reason: 'info' }, { status: 'fulfilled', value: 'name' } ] */ BigInt BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。在此之前，JS 中安全的最大数字是 9009199254740991，即2^53-1，在控制台中输入 Number.MAX_SAFE_INTEGER 即可查看。超过这个值，JS 没有办法精确表示。另外，大于或等于2的1024次方的数值，JS 无法表示，会返回 Infinity。 BigInt 即解决了这两个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。为了和 Number 类型进行区分，BigInt 类型的数据必须添加后缀 n. //Number类型在超过9009199254740991后，计算结果即出现问题 const num1 = 90091992547409910; console.log(num1 + 1); //90091992547409900 //BigInt 计算结果争取 const num2 = 90091992547409910n; console.log(num2 + 1n); //90091992547409911n //Number 类型不能表示大于 2 的 1024 次方的数值 let num3 = 9999; for(let i = 0; i 我们还可以使用 BigInt 对象来初始化 BigInt 实例：(注意：没有 new 关键字！！！)需要说明的是，BigInt 和 Number 是两种数据类型，不能直接进行四则运算，不过可以进行比较操作。 GlobalThis 从不同的 JavaScript 环境中获取全局对象需要不同的语句。在 Web 中，可以通过 window、self 取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。ES2020 中引入 globalThis 作为顶层对象，在任何环境下，都可以简单的通过 globalThis 拿到顶层对象。 空值合并运算符?? 当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。使用 || 操作符，当左侧的操作数为 0 、 null、 undefined、 NaN、 false、 '' 时，都会使用右侧的操作数。如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为。 可选链操作符 ?. const obj = { a: 1 } console.log(obj.a) // 1 console.log(obj.b) // undefined console.log(obj.b.c) // 报错 console.log(obj.b?.c) // undefined Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"vue/路由导航守卫.html":{"url":"vue/路由导航守卫.html","title":"路由导航守卫","keywords":"","body":"路由导航守卫 导航守卫项目中一般用的比较少，只有特定的需求才会用到。我这里讲的是router.beforeEach，一般在项目中，有些权限的设置就会用到，用户是否是登录状态由后端返回的token字段来确定，当进入一个页面之前，一般会对用户的登录状态进行判断，如果过是登录状态就正常进入，如果不是，就强制用户进入登录页面。下面是代码实例。 import router from './index' router.beforeEach((to, from, next) => { // to 将要访问的路径 // from 代表从哪个路径跳转而来 // next 是一个函数，表示放行 // next() 放行 next('/login') 强制跳转 if (to.meta.pathName === '登录页') return next() let isToken = utils.CK.get('token') if (isToken) { return next() } else { return next('/login') } }) Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"vue/虚拟dom和diff算法.html":{"url":"vue/虚拟dom和diff算法.html","title":"虚拟dom与diff算法","keywords":"","body":"虚拟dom和diff算法 什么是虚拟dom？ 所谓虚拟dom就是用一个js对象来描述一个dom节点 我是内容 { tag:'div', // 元素标签 attrs:{ // 属性 class:'a', id:'b' }, text:'我是内容', // 文本内容 children:[] // 子元素 } 为什么要有虚拟dom？ 因为浏览器把真实dom设计的很复杂，即使是一个空的div也有很多东西，这也导致了操作dom非常的消耗性能，使用虚拟dom的目的就是优化性能（用js的计算性能换取操作dom的性能），尽可能的避免dom操作。通过diff算法对比前后虚拟dom，把需要改变的地方改变。 // vue的源码中有一个VNode类用来实例化各种虚拟dom // 源码位置：src/core/vdom/vnode.js export default class VNode { constructor ( tag?: string, data?: VNodeData, children?: ?Array, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) { this.tag = tag /*当前节点的标签名*/ this.data = data /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.children = children /*当前节点的子节点，是一个数组*/ this.text = text /*当前节点的文本*/ this.elm = elm /*当前虚拟节点对应的真实dom节点*/ this.ns = undefined /*当前节点的名字空间*/ this.context = context /*当前组件节点对应的Vue实例*/ this.fnContext = undefined /*函数式组件对应的Vue实例*/ this.fnOptions = undefined this.fnScopeId = undefined this.key = data && data.key /*节点的key属性，被当作节点的标志，用以优化*/ this.componentOptions = componentOptions /*组件的option选项*/ this.componentInstance = undefined /*当前节点对应的组件的实例*/ this.parent = undefined /*当前节点的父节点*/ this.raw = false /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.isStatic = false /*静态节点标志*/ this.isRootInsert = true /*是否作为跟节点插入*/ this.isComment = false /*是否为注释节点*/ this.isCloned = false /*是否为克隆节点*/ this.isOnce = false /*是否有v-once指令*/ this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false } get child (): Component | void { return this.componentInstance } } 通过源代码可以清晰的看出，VNode可以有多种类型： 1.注释节点 2.文本节点 3.元素节点 4.组件节点 5.函数式组件节点 6.克隆节点 在视图渲染之前，把写好的template模板先编译成VNode并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的VNode与前一次缓存下来的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入到视图中，最终完成一次视图更新。 diff算法 打patch补丁，以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事。通俗的来说就是之前的视图有一个虚拟dom，当数据改变会生成新的虚拟dom，新的虚拟dom会与之前的作比较，然后根据比较的结果做增删改，也就是在原来的基础上做改变。（优化主要体现在子节点上，包括到vue3.0的改变也主要是体现在子节点上） 流程图如下： Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"vue/vue路由实现原理.html":{"url":"vue/vue路由实现原理.html","title":"vue路由实现原理","keywords":"","body":"vue路由实现原理 结果：通过更改url地址来更新视图，但是不重新请求页面。 实现：浏览器环境两种（hash和history），node环境一种（abstract）。 hash hash(\"#\") 的作用是加载 URL 中指示网页中的位置。# 本身以及它后面的字符称为 hash，可通过 window.location.hash 获取。hash不会在http请求中，对服务端无用，只是用来指导浏览器动作的。所以改变hash不会重新加载页面。而且hash的改变可以通过hashchange事件进行监听。HashHistory 拥有两个方法，一个是 push（将新路由放到浏览历史栈顶）， 一个是 replace（新路由替代当前路由） $router.push() //调用方法 HashHistory.push() //根据hash模式调用,设置hash并添加到浏览器历史记录（添加到栈顶）（window.location.hash= XXX） History.transitionTo() //监测更新，更新则调用History.updateRoute() History.updateRoute() //更新路由 {app._route= route} //替换当前app路由 vm.render() //更新视图 history 从HTML5开始，History interface 提供了2个新的方法：pushState()、replaceState()使得我们可以对浏览器历史记录栈进行修改，通过back()、forward()、go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。stateObject：当浏览器跳转到新的状态时，将触发 Popstate 事件，该事件将携带这个 stateObject 参数的副本title：所添加记录的标题。url：所添加记录的url。这2个方法有个共同的特点：当调用他们修改浏览器历史栈后，虽然当u前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。 window.history.pushState(stateObject,title,url) window.history.replaceState(stateObject,title,url) 与hash模式做比较： 1.push 只是将window.hash改为history.pushState 2.replace 只是将window.replace改为history.replaceState 3.监听地址变化 在HTML5History的构造函数中监听popState（window.onpopstate） Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "},"vue/vue与elementui实现递归组件菜单.html":{"url":"vue/vue与elementui实现递归组件菜单.html","title":"vue与elementui实现递归组件菜单","keywords":"","body":"vue与elementui实现递归组件菜单 主要讲如何使用vue实现一个递归组件，一般这种组件，多用于项目中的导航菜单。递归的主要思想就是自己调用自己，然后有结束条件。递归组件也是一样，在组建内使用自己（需要注意的是一个name属性，这个属性相当于组件的标识，自己调用自己就用的这个，其实keep-alive用到的exclude等也是这个属性而不是路由里面的name。），下面是我写的一个递归的导航菜单，毕竟看代码实例来的更清晰点。 主菜单 import menuItem from \"./menuItem\"; export default { name: \"leftMenu\", components: { menuItem, }, data() { return { activeIndex: null, // 当前展开菜单 menuData: [ { id: \"0\", title: \"首页\", router: \"/home\", icon: \"el-icon-s-home\", children: [], }, { id: \"1\", title: \"巡检\", icon: \"el-icon-place\", router: \"/home\", children: [ { id: \"1-0\", title: \"智能巡检设置\", icon: \"\", router: \"/home\", children: [], }, { id: \"1-1\", title: \"巡检记录\", icon: \"\", router: \"/home\", children: [], }, { id: \"1-2\", title: \"人工巡检任务\", icon: \"\", router: \"/home\", children: [], }, { id: \"1-3\", title: \"故障维修\", icon: \"\", router: \"/home\", children: [], }, { id: \"1-4\", title: \"保养维护任务\", icon: \"\", router: \"/home\", children: [], }, ], }, { id: \"2\", title: \"设备管理\", icon: \"el-icon-s-management\", router: \"\", children: [ { id: \"2-0\", title: \"设备管理\", icon: \"\", router: \"/home\", children: [], }, { id: \"2-1\", title: \"设备生命周期管理\", icon: \"\", router: \"/home\", children: [], }, ], }, { id: \"3\", title: \"告警管理\", icon: \"el-icon-sunrise\", router: \"/home\", children: [ { id: \"3-0\", title: \"巡检告警\", icon: \"\", router: \"/home\", children: [], }, ], }, { id: \"4\", title: \"消息中心\", icon: \"el-icon-chat-dot-square\", router: \"/home\", children: [ { id: \"4-0\", title: \"消息列表\", icon: \"\", router: \"/home\", children: [], }, ], }, { id: \"5\", title: \"系统管理\", icon: \"el-icon-setting\", router: \"/home\", children: [ { id: \"5-0\", title: \"用户管理\", icon: \"\", router: \"/home\", children: [ { id: \"5-0-1\", title: \"权限管理\", icon: \"\", router: \"/home\", children: [], }, ], }, { id: \"5-1\", title: \"角色管理\", icon: \"\", router: \"/home\", children: [], }, { id: \"5-2\", title: \"权限管理\", icon: \"\", router: \"/home\", children: [], }, ], }, ], }; }, computed: {}, mounted() {}, methods: {}, watch: { $route: { // 监听路由，确保刷新后当前页面与导航状态一致。 handler(val) { this.activeIndex = val.meta.id; }, deep: true, immediate: true, }, }, }; .lj-left-menu { width: 100%; height: 100%; overflow: auto; } 递归组件 export default { name: \"menuItem\", data() { return { nowRouter: null, }; }, props: { menuData: { type: Array, default: () => {}, }, }, computed: {}, mounted() { this.nowRouter = this.$route.path; }, methods: { // 路由跳转 goRouter(data) { if (this.nowRouter === data) { return; } else { this.nowRouter = data; this.$router.push(data); } }, }, }; .el-menu-item.is-active { background: linear-gradient(90deg, #2b579c 0%, rgba(52, 89, 150, 0) 100%); border-left: 2px solid #0086ff; } .el-menu-item:focus, .el-menu-item:hover { background: linear-gradient(90deg, #2b579c 0%, rgba(52, 89, 150, 0) 100%); border-left: 2px solid #0086ff; } .el-submenu__title { i { color: #00d7ff !important; } } .el-menu-item, .el-submenu__title { display: flex; justify-content: flex-start; align-items: center; .radius { width: 8px; height: 8px; background: #468ffe; opacity: 0.6; border-radius: 50%; margin-right: 10px; } i { color: #00d7ff !important; } } Copyright © lujiannb@qq.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-05-11 14:44:39 "}}